package graphStreamVisualizer;

import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.List;

import graphStateAbstraction.Test;

import org.graphstream.graph.Edge;
import org.graphstream.graph.Graph;
import org.graphstream.graph.Node;
import org.graphstream.graph.implementations.*;
import org.graphstream.ui.view.Viewer;

import stateAbstractor.PhiSAReal;
import stateAbstractor.StateAbstractor;
import SARealGenerators.qValueGenerator;
import burlap.domain.singleagent.graphdefined.GraphDefinedDomain;
import burlap.oomdp.core.Domain;
import burlap.oomdp.core.TransitionProbability;
import burlap.oomdp.core.states.State;
import burlap.oomdp.singleagent.Action;
import burlap.oomdp.singleagent.GroundedAction;
import burlap.oomdp.singleagent.RewardFunction;
import burlap.oomdp.statehashing.HashableStateFactory;

public class GraphStreamVisualizer {
	private GraphDefinedDomain d;
	int numStates;
	RewardFunction rf;

	public GraphStreamVisualizer(GraphDefinedDomain d, int numStates, RewardFunction rf) {
		this.d = d;
		this.numStates = numStates;
		this.rf = rf;
	}

	public void render() {	
		Graph graph = new MultiGraph("Tutorial 1");	
		Domain dom = d.generateDomain();

		for (int stateIndex = 0; stateIndex < numStates; stateIndex++) {
			//Add nodes for each state.
			Node node = graph.addNode(Integer.toString(stateIndex));
			node.addAttribute("ui.label", Integer.toString(stateIndex));
		}


		//Add transition probabilities/edges.
		for (int stateIndex = 0; stateIndex < numStates; stateIndex++) {
			//Add nodes for each state.
			State currState = GraphDefinedDomain.getState(dom, stateIndex);

			for (Action a : dom.getActions()) {
				GroundedAction ga = a.getAssociatedGroundedAction();

				List<TransitionProbability> tProbs = ga.getTransitions(currState);
				for (TransitionProbability tProb : tProbs) {
					State sPrime = tProb.s;
					double prob = tProb.p;
					//TODO ADD PROBABILITY

					int otherStateIndex = GraphDefinedDomain.getNodeId(sPrime);

					//TODO DONT SKIP SELF LOOPS
//					if (stateIndex != otherStateIndex) {
						boolean directed = true;
						DecimalFormat df = new DecimalFormat("#.#");
						df.setRoundingMode(RoundingMode.DOWN);
						String probString = df.format(prob);
						Edge e = graph.addEdge(Integer.toString(stateIndex) + Integer.toString(otherStateIndex) + ga.actionName(), Integer.toString(stateIndex), Integer.toString(otherStateIndex), directed);
						e.addAttribute("ui.label", probString + ", " + rf.reward(currState, ga, sPrime));
//					}
				}
			}


		}

		Viewer view = graph.display();
	}

	public static void main(String[] args) {
		int n = 5;

		double epsilon = 10;
		State gInitialState = GraphDefinedDomain.getState(d, 0);
		RewardFunction rf = new Test.nStateChainRF(n);
		qValueGenerator qGen = new qValueGenerator(d, rf, .99, gInitialState);
		StateAbstractor qPhi = new PhiSAReal(qGen, epsilon, d.getActions());
		HashableStateFactory hfA = new SimpleHashableStateFactory();
		GraphDefinedDomain absDG = qPhi.abstractMDP(dg, rf);
		RewardFunction rfA = qPhi.getRewardFunction();
		Domain absD= absDG.generateDomain();
		
		
		GraphDefinedDomain dg = Test.getNStateChain(n);
		RewardFunction rf = new Test.nStateChainRF(n);
		GraphStreamVisualizer test = new GraphStreamVisualizer(dg, n, rf);
		test.render();
	}

}
